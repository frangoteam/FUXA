<svg version="1.1" id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 100 100" xml:space="preserve"><desc>Copyright Opto 22</desc> 
<g>
<g id="shape">
	<path fill="#4D4D4D" d="M75.384,21.591v2.332h-3.877v2.681h-9.96c-0.011,0-0.021,0.005-0.032,0.006V20.34
		c0-1.032-4.343-1.898-10.212-2.144V6.052h2.269V1.891h2.332V0H39.893v1.891h2.332v4.161h2.269v12.145
		c-5.87,0.246-10.212,1.111-10.212,2.144v20.616l8.747,33.146h-0.804v4.161h-2.332v1.891h5.013v5.642h-7.994v-1.702h-3.026v1.702
		v5.855h-2.977c-0.229-0.836-0.663-1.408-1.167-1.408h-0.887V88.18l-0.75-1.654h-1.769l-0.75,1.654v2.062h-1.103
		c-0.741,0-1.342,1.223-1.342,2.732c0,1.509,0.601,2.732,1.342,2.732h5.259c0.504,0,0.938-0.572,1.167-1.408h2.977v3.223v1.702
		h3.026V97.52h22.316v1.702h3.026V97.52V85.795v-1.702h-3.026v1.702h-8.336v-5.642h5.013v-1.891h-2.332v-4.161h-0.804l8.747-33.146
		v-8.372c0.011,0,0.021,0.006,0.032,0.006h9.96v2.681h3.877v2.332h1.891V21.591H75.384z"></path>
</g>
<g id="light">
	<path fill="#B3B3B3" d="M44.906,80.153v6.635c0,0.576,0.535,1.083,1.344,1.379v-8.014H44.906z"></path>
	<path fill="#B3B3B3" d="M43.724,74.101l-7.553-33.146V19.213c-1.2,0.33-1.888,0.715-1.888,1.127v20.616l8.747,33.146H43.724z"></path>
	<path fill="#B3B3B3" d="M44.495,6.052v12.145c0.326-0.014,0.665-0.022,1-0.032V6.052H44.495z"></path>
	<rect x="42.226" y="1.891" fill="#B3B3B3" width="1" height="4.161"></rect>
	<rect x="71.507" y="24.423" fill="#B3B3B3" width="0.5" height="2.597"></rect>
	<rect x="39.893" fill="#B3B3B3" width="0.5" height="1.891"></rect>
</g>
<g id="shadow">
	<path fill="#1A1A1A" d="M50.892,80.153v6.635c0,0.576-0.535,1.083-1.344,1.379v-8.014H50.892z"></path>
	<path fill="#1A1A1A" d="M61.515,26.61c0-2.654,0-6.269,0-6.269c0-0.411-0.688-0.797-1.888-1.127v21.743l-7.553,33.146h0.695
		l8.747-33.146c0,0,0-4.334,0-8.372c-0.899-0.031-1.623-1.354-1.623-2.987C59.893,27.963,60.617,26.641,61.515,26.61z"></path>
	<path fill="#1A1A1A" d="M60.321,31.589c0.303,0.609,0.738,1,1.226,1h9.96v-1H60.321z"></path>
	<rect x="36.912" y="96.52" fill="#1A1A1A" width="22.316" height="1"></rect>
	<path fill="#1A1A1A" d="M51.303,6.052h-1v12.112c0.335,0.01,0.674,0.018,1,0.032V6.052z"></path>
	<rect x="36.912" y="92.333" fill="#1A1A1A" width="1" height="4.187"></rect>
	<path fill="#1A1A1A" d="M29.742,90.242h-5.259c-0.287,0-0.552,0.187-0.77,0.5h6.799C30.294,90.429,30.029,90.242,29.742,90.242z"></path>
	<path fill="#1A1A1A" d="M23.453,94.705c0.246,0.606,0.614,1,1.03,1h5.259c0.416,0,0.784-0.394,1.03-1H23.453z"></path>
	<path fill="#1A1A1A" d="M33.886,93.797h-2.871c-0.027,0.175-0.063,0.342-0.106,0.5h2.977V93.797z"></path>
	<rect x="52.573" y="74.601" fill="#1A1A1A" width="1" height="3.661"></rect>
	<rect x="44.495" y="6.052" fill="#1A1A1A" width="6.808" height="0.5"></rect>
	<rect x="52.573" y="1.891" fill="#1A1A1A" width="1" height="4.161"></rect>
	<rect x="49.726" y="1.891" fill="#1A1A1A" width="3.847" height="0.5"></rect>
	<rect x="71.507" y="34.27" fill="#1A1A1A" width="3.877" height="1"></rect>
</g>
<g id="hlight">
	<path fill="#E6E6E6" d="M47.899,18.123c-7.52,0-13.616,0.992-13.616,2.217c0,0,0,0.908,0,1c0-1.224,6.096-2.717,13.616-2.717
		V18.123z"></path>
	<path fill="#E6E6E6" d="M71.507,26.604h-9.96c-0.489,0-0.923,0.391-1.226,1h11.187V26.604z"></path>
	<polygon fill="#E6E6E6" points="36.912,85.795 36.912,86.795 44.908,86.795 44.906,86.788 44.906,85.795 	"></polygon>
	<path fill="#E6E6E6" d="M32.667,87"></path>
	<polygon fill="#E6E6E6" points="59.228,85.795 50.892,85.795 50.892,86.788 50.891,86.795 59.228,86.795 	"></polygon>
	<polygon fill="#E6E6E6" points="62.254,85.093 62.254,84.093 59.228,84.093 59.228,88.222 59.728,88.222 59.728,85.093 	"></polygon>
	<polygon fill="#E6E6E6" points="36.912,85.093 36.912,84.093 33.886,84.093 33.886,88.222 34.386,88.222 34.386,85.093 	"></polygon>
	<polygon fill="#E6E6E6" points="43.226,74.601 45.073,74.601 45.073,74.101 42.226,74.101 42.226,78.262 43.226,78.262 	"></polygon>
	<polygon fill="#E6E6E6" points="40.893,78.762 45.655,78.762 45.655,78.262 39.893,78.262 39.893,80.153 40.893,80.153 	"></polygon>
	<rect x="71.507" y="23.923" fill="#E6E6E6" width="3.877" height="0.5"></rect>
</g>
</g>

  <script type="text/javascript">
    <![CDATA[
    /*
    #####################################
    #           How to Use              #
    #####################################

    Variables with the following prefix:

    _pb_ = bool   parameter ( true or false )
    _pn_ = number parameter ( Int, Float, Real etc )
    _ps_ = string parameter ( string can be entered directly )
    _pc_ = color parameter in hex color code ( #00ff00ff )

    Indicate variable type to be used in Fuxa Properties and binding of Tags, Important! they have to be place within:

    //!export-start
    let _pn_setState = 0;
    //!export-end

  

    There are 2x Functions to handle sending and receiving data between Fuxa and the SVG

    // Recieve Variables From Fuxa
    function putValue(id, value) { } 
    
    // Send Variables To Fuxa
    function postValue(id, value) {
      console.error('Not defined!');
    }

    The ID is the name of the variable _pn_setState for example and value is the value to be sent or received from Fuxa


    This SVG uses an INT/Number Variable to change the State and State of the SVG:

    0 = Off
    1 = Run
    2 = Warning
    3 = Fault
    4 = Invalid
    5 = Spare

    You can also use the bool field and this will change the state between 0 = off and 1 = run 

    You can also set the color for each state in Fuxa using HEX color code #b4b4b4
    The Default Blink Interval is 500ms but can also be changed in Fuxa in MS resolution


    This SVG is a bit complex as we have different shades of color, we calculate the offset colors
    The Shade Values are from -100 to 100, where 0 is not changed and -100 is black and 100 is white

    These style of SVGs can be found here:

    https://www.opto22.com/support/resources-tools/demos/svg-image-library

    By Adding this script to there downloaded SVG it should work without any modification ( may have to check group element names )
    Make sure the script is within the SVG tags

    <svg>
      SVG Content Here
      <script>
        JS Script Content Here
      </script>
    </svg>

    */

	  // Global Parameters and Variables
    //!export-start
    let _pn_setState         = 0;
    let _pb_boolState        = false;
	  let _pn_setInterval      = 500;
    let _pc_state0Colour     = '#b4b4b4';
    let _pc_state1Colour     = '#00ff00';
    let _pc_state2Colour     = '#ff9500';
    let _pc_state3Colour     = '#ff0000';
    let _pc_state4Colour     = '#3c3c3c';
    let _pc_state5Colour     = '#dcdcdc';
    let _pn_lightShade       = 50;
    let _pn_highLightShade   = 90;
    let _pn_darkShade        = 15;
    let _pn_shadowShade      = -15;
    //!export-end
	  let stateNumber = 0;
    let blinkInterval;

    // Function to update the color based on the set state
    function logic() {

      switch (stateNumber) {
        case 0: // off
          setBaseColor( _pc_state0Colour);
		      clearBlinking();
          break; 
        case 1: // run
          setBaseColor( _pc_state1Colour);
		      clearBlinking();
          break;
        case 2: // warning
          setBaseColor( _pc_state2Colour);
		      clearBlinking();
          break;
        case 3: // fault
		      startBlinking( _pc_state0Colour, _pc_state3Colour, _pn_setInterval );
          break;
        case 4: // invalid 
          setBaseColor( _pc_state4Colour);
		      clearBlinking();
          break;
        case 5: // spare
          setBaseColor( _pc_state5Colour);
		      clearBlinking();
          break;
        default:
          console.log('Undefined State');
		      clearBlinking();
      }
    }

    // Initial setup
    function init() {
      logic(); // Initial state rendering
    }

    // Function to update values from Fuxa
    function putValue(id, value) {
      if (id === '_pn_setState') {
        stateNumber = value;
        logic(); 
      }
      if (id === '_pb_boolState') {
        _pb_boolState = value;
        if (_pb_boolState === true) {
          stateNumber = 1;
        } else if (_pb_boolState === false) {
          stateNumber = 0;
        }
        logic(); 
      }
	    if (id === '_pn_setInterval'   ) _pn_setInterval    = value;
      if (id === '_pc_state0Colour'  ) _pc_state0Colour   = value;
      if (id === '_pc_state1Colour'  ) _pc_state1Colour   = value;
      if (id === '_pc_state2Colour'  ) _pc_state2Colour   = value;
      if (id === '_pc_state3Colour'  ) _pc_state3Colour   = value;
      if (id === '_pc_state4Colour'  ) _pc_state4Colour   = value;
      if (id === '_pc_state5Colour'  ) _pc_state5Colour   = value;
      if (id === '_pn_lightShade'    ) _pn_lightShade     = value;
      if (id === '_pn_highLightShade') _pn_highLightShade = value;
      if (id === '_pn_darkShade'     ) _pn_darkShade      = value;
      if (id === '_pn_shadowShade'   ) _pn_shadowShade    = value;
    }

    // Function to send values back to Fuxa (placeholder)
    function postValue(id, value) {
      console.error('Not defined!');
    }

    // Initialize the SVG
    init();

	// Function to update the color for the base shape group
    function setBaseColor(baseColor) {
      // Define color manipulations based on base color
      const darkColor   = percentColor(baseColor, _pn_darkShade);
      const shadowColor = percentColor(baseColor, _pn_shadowShade);
      const lightColor  = percentColor(baseColor, _pn_lightShade);
      const hlightColor = percentColor(baseColor, _pn_highLightShade);

	  document.getElementById('shape').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', baseColor);
      });
      //document.getElementById('dark').querySelectorAll('*').forEach(function(elem) {
      //elem.setAttribute('fill', darkColor);
      //});
      document.getElementById('shadow').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', shadowColor);
      });
      document.getElementById('light').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', lightColor);
      });
	  document.getElementById('hlight').querySelectorAll('*').forEach(function(elem) {
      elem.setAttribute('fill', hlightColor);
      });
	}

    // Function to manipulate color brightness/darkness (-100% = Black) (0 = unchanged) (100% = White)
    function percentColor(color, percent) {
      let R = parseInt(color.substring(1, 3), 16);
      let G = parseInt(color.substring(3, 5), 16);
      let B = parseInt(color.substring(5, 7), 16);

      // Calculate the adjustment factor based on the percentage
      if (percent > 0) {
          // Lightening - move each channel closer to 255 (white)
          R = Math.round(R + (255 - R) * (percent / 100));
          G = Math.round(G + (255 - G) * (percent / 100));
          B = Math.round(B + (255 - B) * (percent / 100));
      } else {
          // Darkening - move each channel closer to 0 (black)
          R = Math.round(R * (1 + (percent / 100)));
          G = Math.round(G * (1 + (percent / 100)));
          B = Math.round(B * (1 + (percent / 100)));
      }

      // Clamp values to the [0, 255] range
      R = Math.max(0, Math.min(255, R));
      G = Math.max(0, Math.min(255, G));
      B = Math.max(0, Math.min(255, B));

      // Convert back to hexadecimal
      const RR = (R.toString(16).length === 1) ? "0" + R.toString(16) : R.toString(16);
      const GG = (G.toString(16).length === 1) ? "0" + G.toString(16) : G.toString(16);
      const BB = (B.toString(16).length === 1) ? "0" + B.toString(16) : B.toString(16);

      return "#" + RR + GG + BB;
    }

	// Function to start blinking between two colors
    function startBlinking(color1, color2, interval) {
      clearBlinking(); // Clear any existing blinking interval
    
      let isColor1 = true; 
      blinkInterval = setInterval(function() {
        const checkDestroy = document.getElementById('Layer_1'); // Important must be name of the SVG!
        if (!checkDestroy) {
          clearBlinking(); 
          return;
        }
        if (isColor1) {
          setBaseColor(color1); 
        } else {
          setBaseColor(color2); 
        }
        isColor1 = !isColor1; 
      }, interval);

      // Set up the MutationObserver to watch for removal of the SVG element
      const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
          mutation.removedNodes.forEach((node) => {
            if (node.id === 'Layer_1') { // Important must be name of the SVG!
              clearBlinking(); 
              observer.disconnect(); 
            }
          });
        });
      });

      // Start observing the body or a parent element of the SVG
      observer.observe(document.body, { childList: true, subtree: true }); 
    }

    // Function to clear the blinking interval
    function clearBlinking() {
      if (blinkInterval) {
        clearInterval(blinkInterval);
        blinkInterval = null;
      }
    }

    ]]>
  </script>

</svg>